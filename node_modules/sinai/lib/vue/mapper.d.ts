import { VueStore } from './store';
import { BG0, BM0, BA0 } from '../core/base';
declare type State<ST extends VueStore<any, any, any, any>> = ST extends VueStore<infer S, any, any, any> ? S : never;
declare type Getters<ST extends VueStore<any, any, any, any>> = ST extends VueStore<any, infer G, any, any> ? G : never;
declare type Mutations<ST extends VueStore<any, any, any, any>> = ST extends VueStore<any, any, infer M, any> ? M : never;
declare type Actions<ST extends VueStore<any, any, any, any>> = ST extends VueStore<any, any, any, infer A> ? A : never;
declare type Module<S, G, M, A> = keyof S & keyof G & keyof M & keyof A;
export declare class VueMapper<S, G, M, A> {
    private _module;
    constructor(_module: string[]);
    module<T extends Module<S, G, M, A>>(module: T): VueMapper<S[T], G[T], M[T], A[T]>;
    mapState<Key extends keyof S>(keys: Key[]): {
        [K in Key]: () => S[K];
    };
    mapState<T extends Record<string, keyof S>>(map: T): {
        [K in keyof T]: () => S[T[K]];
    };
    mapGetters<Key extends keyof G>(keys: Key[]): {
        [K in Key]: () => G[K];
    };
    mapGetters<T extends Record<string, keyof G>>(map: T): {
        [K in keyof T]: () => G[T[K]];
    };
    mapMutations<Key extends keyof M>(keys: Key[]): {
        [K in Key]: M[K];
    };
    mapMutations<T extends Record<string, keyof M>>(map: T): {
        [K in keyof T]: M[T[K]];
    };
    mapActions<Key extends keyof A>(keys: Key[]): {
        [K in Key]: A[K];
    };
    mapActions<T extends Record<string, keyof A>>(map: T): {
        [K in keyof T]: A[T[K]];
    };
}
export declare function createMapper<ST extends VueStore<{}, BG0, BM0, BA0>>(): VueMapper<State<ST>, Getters<ST>, Mutations<ST>, Actions<ST>>;
export {};
