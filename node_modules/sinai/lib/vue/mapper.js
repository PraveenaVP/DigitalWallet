import { getByPath } from '../utils';
function normalizeMap(map, fn) {
    var res = {};
    if (Array.isArray(map)) {
        map.forEach(function (key) {
            res[key] = fn(key, key);
        });
    }
    else {
        Object.keys(map).forEach(function (key) {
            res[key] = fn(map[key], key);
        });
    }
    return res;
}
var VueMapper = /** @class */ (function () {
    function VueMapper(_module) {
        this._module = _module;
    }
    VueMapper.prototype.module = function (module) {
        return new VueMapper(this._module.concat(module));
    };
    VueMapper.prototype.mapState = function (map) {
        var _this = this;
        return normalizeMap(map, function (value) {
            var path = _this._module.concat(value);
            return function stateMapper() {
                return getByPath(path, this.$store.state);
            };
        });
    };
    VueMapper.prototype.mapGetters = function (map) {
        var _this = this;
        return normalizeMap(map, function (value) {
            var path = _this._module.concat(value);
            return function getterMapper() {
                return getByPath(path, this.$store.getters);
            };
        });
    };
    VueMapper.prototype.mapMutations = function (map) {
        var _this = this;
        return normalizeMap(map, function (value) {
            var path = _this._module.concat(value);
            return function mutationMapper() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                // It never return non-callable value since we have runtime assertion in the module
                return getByPath(path, this.$store.mutations).apply(void 0, args);
            };
        });
    };
    VueMapper.prototype.mapActions = function (map) {
        var _this = this;
        return normalizeMap(map, function (value) {
            var path = _this._module.concat(value);
            return function actionMapper() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                // It never return non-callable value since we have runtime assertion in the module
                return getByPath(path, this.$store.actions).apply(void 0, args);
            };
        });
    };
    return VueMapper;
}());
export { VueMapper };
export function createMapper() {
    return new VueMapper([]);
}
